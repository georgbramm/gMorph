var N=null,E="",T="t",U="u",searchIndex={};
var R=["encode","gmorph","encrypt","Output","keypair","gmorph::encode","result","gmorph::encrypt","try_from","try_into","borrow_mut","to_subset","is_in_subset","to_subset_unchecked","from_subset","quaternionm","encoded","formatter"];

searchIndex["gmorph"]={"doc":"gMorph - Fully Homomorphic Encryption library `gMorph` is…","i":[[0,R[0],R[1],"Types and traits which lift `u32` type to FHE compatible…",N,N],[3,"Encoded",R[5],"Wrapper type for lifting `u32` type to FHE compatible form",N,N],[8,"Encode",E,"Helper trait for encoding `T` into some value `Self`",N,N],[10,R[0],E,"Encodes `T` into `Self`",0,[[[T]],["self"]]],[8,"Decode",E,"Helper trait for decoding `Self` into `T`",N,N],[10,"decode",E,"Decodes `Self` into `T`",1,[[["self"]],[T]]],[0,R[2],R[1],"Types and traits which allow for encrypting/decrypting of…",N,N],[3,"KeyPair",R[7],"Type representing a key pair which can be used for…",N,N],[8,"Encrypt",E,"Helper trait for encrypting `Self`",N,N],[16,R[3],E,E,2,N],[10,R[2],E,"Encrypts `Self` using `key_pair` and outputs `Self::Output`",2,[[["self"],[R[4]]]]],[8,"Decrypt",E,"Helper trait for decrypting `Self`",N,N],[16,R[3],E,E,3,N],[10,"decrypt",E,"Decrypts `Self` using `key_pair` and outputs `Self::Output`",3,[[["self"],[R[4]]]]],[11,"into",R[5],E,4,[[],[U]]],[11,"from",E,E,4,[[[T]],[T]]],[11,"to_owned",E,E,4,[[["self"]],[T]]],[11,"clone_into",E,E,4,[[["self"],[T]]]],[11,R[8],E,E,4,[[[U]],[R[6]]]],[11,R[9],E,E,4,[[],[R[6]]]],[11,"borrow",E,E,4,[[["self"]],[T]]],[11,R[10],E,E,4,[[["self"]],[T]]],[11,"type_id",E,E,4,[[["self"]],["typeid"]]],[11,R[11],E,E,4,[[["self"]],["option"]]],[11,R[12],E,E,4,[[["self"]],["bool"]]],[11,R[13],E,E,4,[[["self"]],["ss"]]],[11,R[14],E,E,4,[[["ss"]],["sp"]]],[11,"vzip",E,E,4,[[],["v"]]],[11,"into",R[7],E,5,[[],[U]]],[11,"from",E,E,5,[[[T]],[T]]],[11,R[8],E,E,5,[[[U]],[R[6]]]],[11,R[9],E,E,5,[[],[R[6]]]],[11,"borrow",E,E,5,[[["self"]],[T]]],[11,R[10],E,E,5,[[["self"]],[T]]],[11,"type_id",E,E,5,[[["self"]],["typeid"]]],[11,R[11],E,E,5,[[["self"]],["option"]]],[11,R[12],E,E,5,[[["self"]],["bool"]]],[11,R[13],E,E,5,[[["self"]],["ss"]]],[11,R[14],E,E,5,[[["ss"]],["sp"]]],[11,"vzip",E,E,5,[[],["v"]]],[11,R[0],R[5],E,4,[[["u32"]],["self"]]],[11,R[0],E,E,4,[[["u32"]],["self"]]],[11,"decode",E,E,4,[[["self"]],["u32"]]],[11,R[2],E,E,4,[[["self"],[R[4]]]]],[11,"decrypt",E,E,4,[[["self"],[R[4]]]]],[11,"default",R[7],E,5,[[],["self"]]],[11,"clone",R[5],E,4,[[["self"]],[R[16]]]],[11,"from",E,E,4,[[["matrix3",[R[15]]],[R[15],["mod231"]]],["self"]]],[11,"from",E,E,4,[[["matrix3"]],["self"]]],[11,"eq",E,E,4,[[["self"],[R[16]]],["bool"]]],[11,"ne",E,E,4,[[["self"],[R[16]]],["bool"]]],[11,"fmt",E,E,4,[[["self"],[R[17]]],[R[6]]]],[11,"fmt",R[7],E,5,[[["self"],[R[17]]],[R[6]]]],[11,"add",R[5],E,4,[[]]],[11,"mul",E,E,4,[[]]],[11,"add_assign",E,E,4,[[["self"]]]],[11,"mul_assign",E,E,4,[[["self"]]]],[11,"zero",E,E,4,[[],["self"]]],[11,"is_zero",E,E,4,[[["self"]],["bool"]]],[11,"one",E,E,4,[[],["self"]]],[11,"is_one",E,E,4,[[["self"]],["bool"]]]],"p":[[8,"Encode"],[8,"Decode"],[8,"Encrypt"],[8,"Decrypt"],[3,"Encoded"],[3,"KeyPair"]]};
initSearch(searchIndex);addSearchOptions(searchIndex);